import json
from collections import defaultdict

# counts read from training set
fp_counts = dict()

# non-terminal symbols
N = set()

# rules in CNF
R = set()


def cky_parse(sentence):
  """ Strict implementation of the algorithm described on p. 14 """

  # initialization
  pi = defaultdict(lambda: 0)

  # split sentence into words
  x = sentence.split()
  n = len(x)

  # prepend one empty element to x so that real word starts at 1
  x.insert(0, None)

  # terminals
  for X in N:
    for i in range(1,n):
      pi[(i,i,X)] = distribution(X, x[i])

  # # non-terminals
  # for l in range(1,n):
  #   for i in range(1,n):
  #     j = i + l





def distribution(x,y1,y2=None):
  print count(x,y1,y2), '/', count(x,y1)
  try:
    return count(x,y1,y2) / count(x,y1)
  except ZeroDivisionError:
    return 0


def count(x,y1=None,y2=None):
  # x,y1,y2 all present: BINARYRULE
  if y1 is not None and y2 is not None:
    try:
      return fp_counts[('BINARYRULE',x,y1,y2)]
    except KeyError:
      try:
        return fp_counts[('BINARYRULE',x,y1,'_RARE_')]
      except KeyError:
        return 0

  # only x,y1: UNARYRULE
  elif y1 is not None:
    try:
      return fp_counts[('UNARYRULE',x,y1)]
    except KeyError:
      try:
        return fp_counts[('UNARYRULE',x,'_RARE_')]
      except KeyError:
        return 0

  # x only: NONTERMINAL
  else:
    try:
      return fp_counts[('NONTERMINAL',x)]
    except KeyError:
      return 0


def cache_counts(lines):
  for line in lines:
    line = line.split()
    if line:
      # cache with fp being the key
      fp = line[1:]
      fp_counts[tuple(fp)] = int(line[0])

      # populate N
      if line[1] == 'NONTERMINAL':
        N.add(line[2])

      # populate R
      if line[1] == 'UNARYRULE':
        R.add((line[2], line[3]))

      if line[1] == 'BINARYRULE':
        R.add((line[2], line[3], line[4]))


if __name__ == '__main__':
  training_lines = open("parse_train.counts.out").readlines()
  cache_counts(training_lines)

  input_lines = open("parse_dev.dat").readlines()

  for input_line in input_lines:
    cky_parse(input_line)
    break
